<html>
<head>
    <meta charset="UTF-8">

    <style>

    body {
      margin: 1in;
      font-family: 'Futura', sans-serif;
    }

    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <h1>Project 1</h1>
    <h3>Sydney Bednar, Noorejehan Umar, Victoria Eshun</h3>
    <p>Color Palette</p>
    <p style="color: #ff0050">PINK</p>
    <p style="color: #00f2ea">AQUA</p>
    <p>BLACK</p>
    <img src='palette.png' width=300 height=300 />
    <p>
    <svg id="dance" width=500 height=500>
    </svg>

</br>
    <svg id="valence" width=500 height=500>
    </svg>

</br>
    <svg id="energy" width=500 height=500>
    </svg>
</br>
    <svg id="mode" width=500 height=500>
    </svg>

</br>
<svg id="acousticness" width=500 height=500>
</svg>

    <svg id="combo" width=1000 height=800>
    </svg>  
    </p>

    <script>
    const requestData = async function() {
        const data = await d3.csv('TikTok_songs_2022.csv', d3.autoType);
        console.log(data);


        const svg1=d3.select("svg#dance")
        const width = svg1.attr("width");
        const height = svg1.attr("height");
        const margin = {top: 50, right: 10, bottom: 50, left: 50};
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        let annotations = svg1.append("g").attr("id","annotations");
        let chartArea = svg1.append("g").attr("id","points")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        const popExtent = d3.extent(data, d => d['track_pop'])
        const popScale = d3.scaleLinear()
                            .domain(popExtent)
                            .range([0, chartWidth])

        let bottomAxis = d3.axisBottom(popScale)

        annotations.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                   .call(bottomAxis)

        // danceability
        const danceExtent = d3.extent(data, d => d['danceability'])
        const danceScale = d3.scaleLinear()
                           .domain(danceExtent)
                           .range([chartHeight, 0])

        console.log(danceExtent)
        let danceAxis = d3.axisLeft(danceScale)

        annotations.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(danceAxis)

        let danceCircles = chartArea.selectAll("circles.dance").data(data)
                            .join("circle")
                            .attr("class", "dance")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => danceScale(d['danceability']))
                            .attr("fill", "#ff0050")
                            .attr("opacity", .6)

        chartArea.append("text")
                .attr("x", (chartWidth / 2))
                .attr("y", 0 - (margin.top / 2))
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text("Danceability");

    

        // energy
        const svg3 = d3.select("svg#energy")

        let annotations3 = svg3.append("g").attr("id","annotations3");
        let chartArea3 = svg3.append("g").attr("id","points3")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        annotations3.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                   .call(bottomAxis)

        // points
        const energyExtent = d3.extent(data, d => d['energy']);
        const energyScale = d3.scaleLinear()
                           .domain(energyExtent)
                           .range([chartHeight, 0]);
        let energyAxis = d3.axisLeft(energyScale);

        annotations3.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(energyAxis);

        let energyCircles = chartArea3.selectAll("circles.energy").data(data)
                            .join("circle")
                            .attr("class", "energy")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => energyScale(d['energy']))
                            .attr("fill", "black")
                            .attr("opacity", .6);

            chartArea3.append("text")
                .attr("x", (chartWidth / 2))
                .attr("y", 0 - (margin.top / 2))
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text("Energy");



        // valence
        const svg4 = d3.select("svg#valence")

        let annotations4 = svg4.append("g").attr("id","annotations4");
        let chartArea4 = svg4.append("g").attr("id","points4")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        annotations4.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                   .call(bottomAxis)

        // points
        const valenceExtent = d3.extent(data, d => d['valence']);
        const valenceScale = d3.scaleLinear()
                           .domain(valenceExtent)
                           .range([chartHeight, 0]);
        let valenceAxis = d3.axisLeft(valenceScale);

        console.log(valenceExtent)

        annotations4.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(valenceAxis);

        let valenceCircles = chartArea4.selectAll("circles.valence").data(data)
                            .join("circle")
                            .attr("class", "valence")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => valenceScale(d['valence']))
                            .attr("fill", "#00f2ea")
                            .attr("opacity", .6);

      chartArea4.append("text")
        .attr("x", (chartWidth / 2))
        .attr("y", 0 - (margin.top / 2))
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .text("Valence");


            // mode
        const svg5 = d3.select("svg#mode")

        let annotations5 = svg5.append("g").attr("id","annotations5");
        let chartArea5 = svg5.append("g").attr("id","points5")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        annotations5.append("g")
                .attr("class", "x axis")
                .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                .call(bottomAxis)

        // points
        const modeExtent = d3.extent(data, d => d['mode']);
        const modeScale = d3.scaleLinear()
                        .domain(modeExtent)
                        .range([chartHeight, 0]);
        let modeAxis = d3.axisLeft(modeScale);

        console.log(modeExtent)

        annotations5.append("g")
                .attr("class", "y axis")
                .attr("transform",`translate(${margin.left-10},${margin.top})`)
                .call(modeAxis);

        let modeCircles = chartArea5.selectAll("circles.mode").data(data)
                            .join("circle")
                            .attr("class", "mode")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => modeScale(d['mode']))
                            .attr("fill", "#00f2ea")
                            .attr("opacity", .6);

        chartArea5.append("text")
        .attr("x", (chartWidth / 2))
        .attr("y", 0 - (margin.top / 2))
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .text("Mode");



                // acousticness
        const svg6 = d3.select("svg#acousticness")

        let annotations6 = svg6.append("g").attr("id","annotations6");
        let chartArea6 = svg6.append("g").attr("id","points6")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        annotations6.append("g")
                .attr("class", "x axis")
                .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                .call(bottomAxis)

        // points
        const acousticnessExtent = d3.extent(data, d => d['acousticness']);
        const acousticnessScale = d3.scaleLinear()
                        .domain(acousticnessExtent)
                        .range([chartHeight, 0]);
        let acousticnessAxis = d3.axisLeft(acousticnessScale);

        console.log(acousticnessExtent)

        annotations6.append("g")
                .attr("class", "y axis")
                .attr("transform",`translate(${margin.left-10},${margin.top})`)
                .call(acousticnessAxis);

        let acousticnessCircles = chartArea6.selectAll("circles.acousticness").data(data)
                            .join("circle")
                            .attr("class", "acousticness")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => acousticnessScale(d['acousticness']))
                            .attr("fill", "#ff0050")
                            .attr("opacity", .6);

        chartArea6.append("text")
        .attr("x", (chartWidth / 2))
        .attr("y", 0 - (margin.top / 2))
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .text("Acousticness");

        

        // Combined chart
        let combo = d3.select("svg#combo")
        const widthC = combo.attr("width");
        const heightC = combo.attr("height");
        const chartWidthC = widthC - margin.left - margin.right-30;
        const chartHeightC = heightC - margin.top - margin.bottom;
        let annotationsC = combo.append("g").attr("id","annotationsC");
        let chartAreaC = combo.append("g").attr("id","pointsC")
                        .attr("transform",`translate(${margin.left+30},${margin.top})`);

        const pop_bin = d3.bin()
                          .value(d => d.track_pop)
                          .thresholds([20, 40, 60, 80, 100]);

        const bins = pop_bin(data);

        data.bins = bins;
        data.bins.upperlimits = new Array();

        bins.forEach(array => {
            var sum_danceability = 0;
            var sum_valence = 0;
            var sum_acousticness = 0;
            var sum_energy = 0;

            array.forEach(element =>{
                sum_danceability += element.danceability;
                sum_valence += element.valence;
                sum_acousticness += element.acousticness;
                sum_energy += element.energy;
            })
            
            
            array.avg_danceability = sum_danceability/array.length;
            array.avg_valence = sum_valence/array.length;
            array.avg_acousticness = sum_acousticness/array.length;
            array.avg_energy = sum_energy/array.length;

            array.pop_range  = [array.x0, array.x1];

            data.bins.upperlimits.push(array.x1)

            
        });


        const popBinsExtent = d3.extent(data.bins.upperlimits);
        

        const labelScale = d3.scalePoint()
                             .domain(['danceability', 'valence', 'acousticness', 'energy'])
                             .range([chartHeightC-50, 50]);

        const xlabelScale = d3.scalePoint()
                             .domain(data.bins.upperlimits)
                             .range([50, chartWidthC-10])
                             .padding(0.1);


        console.log(popBinsExtent);


        let bottomAxisC = d3.axisBottom(xlabelScale)
        let leftAxisC = d3.axisLeft(labelScale).ticks(4)


        annotationsC.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left+30},${chartHeightC+margin.top})`)
                   .call(bottomAxisC)

        annotationsC.append("g")
                 .attr("class", "y axis")
                 .attr("transform",`translate(${margin.left+20},${margin.top})`)
                 .call(leftAxisC);


        const danceScaleC = d3.scaleLinear()
                              .domain(danceExtent)
                              .range([0, chartWidthC])

        const radiusScale= d3.scaleSqrt()
                            .domain(danceExtent)
                            .range([0, 40])

        let danceBubs = chartAreaC.append("g")
                            .selectAll("bubble")
                            .data(data.bins)
                            .enter()
                            .append("circle")
                            .attr("cx", d => xlabelScale(d.x1))
                            .attr("cy", d => chartHeightC-50)
                            .attr("r", d => radiusScale(d.avg_danceability))
                            .style("fill", "lightcyan")
                            .style("opacity", "0.7")
                            .attr("stroke", "black")
                            .attr("stroke-width", 2);
                            
            
    
        console.log(danceExtent)
        

        console.log("bins", bins);
        console.log(bins[0].x1, bins[bins.length-1].x1);

        console.log(chartWidthC)

        // for each bin, take the avg of the 'danceability', 'valence', 'acousticness', 'energy', of all elements in the bin
        // then we have values for each and then we scale it 
        
        

        // console.log(bins[0].avg_danceability)

    }
    requestData();

    </script>
    <!-- // var avg_danceability = sum_danceability/array.length;
    // var avg_valence = sum_valence/array.length;
    // var avg_acousticness = sum_acousticness/array.length;
    // var avg_energy = sum_energy/array.length;
    // const array1 = new Array(avg_danceability, avg_valence, avg_acousticness, avg_energy)
            
            // for (var i = 0; i < names.length; i += 1) {
            //     var data = {};
            //     for (var j = 0; j < array1.length; j += 1){
            //         data[names[j]] = array1[i];
                    
            //     }
            //     array.push(data);
                
            //     // console.log(data)
            //     console.log(array)
            //}

            // console.log(array1);
            
            // console.log('array', bins.indexOf(array), 'avg dance: ', avg_danceability);
            // console.log('array', bins.indexOf(array), 'avg valence: ',avg_valence);
            // console.log('array', bins.indexOf(array), 'avg acoustic: ',avg_acousticness);
            // console.log('array', bins.indexOf(array), 'avg energy: ',avg_energy); -->


</body>
</html>
