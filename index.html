<html>
<head>
    <meta charset="UTF-8">

    <style>

    body {
      margin: 1in;
      font-family: 'Futura', sans-serif;
    }

    .axis {
        font-family: 'Futura', sans-serif;
    }

    .first {
        background-color: rgb(170, 236, 251, .1);
        border: 1px solid rgb(170, 236, 251);
        padding: 40px;
    }

    .title {
        font-weight: bold;

    }

    .artist-pop-text{
        writing-mode: vertical-lr;

    }

    svg.combo{
        padding:50px;
    }

    .axis.combo{
        font-size: 13;
    }

    .im-cover{
        background-color: rgb(118, 179, 193, 0.5);
        border: .5px solid rgb(118, 179, 193);
    }

    div img {
        margin: auto;
        display: block;
    }


    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js"></script>
    <script src="https://unpkg.com/simple-statistics@7.7.6/dist/simple-statistics.min.js"></script>
</head>

<body>
    <h1>Project 1</h1>
    <h3>Sydney Bednar, Noorejehan Umar, Victoria Eshun</h3>
<div class="im-cover">
    <img src='title.png'/>
</div>
<div class="first">
    <div class="top row">
        <svg id="dance" width=500 height=500>
        </svg>

        <svg id="valence" width=500 height=500>
        </svg>
    </div>

    <div class="bottom row">
        <svg id="energy" width=500 height=500>
        </svg>
        <svg id="acousticness" width=500 height=500>
        </svg>
        <!-- <svg id="mode" width=500 height=500>
        </svg> -->
    </div>

</div>
<div class="im-cover">
<img src='title2.png'/>
</div>

<div class="first">

  <svg id="combo" width=1200 height=800>
    </svg>
</div>

</br>
<svg id="artist_pop" width=500 height=500>
</svg>
    </p>

    <script>
    const requestData = async function() {
        const data = await d3.csv('TikTok_songs_2022.csv', d3.autoType);
        console.log(data);


        const svg1=d3.select("svg#dance")
        const width = svg1.attr("width");
        const height = svg1.attr("height");
        var margin = {top: 50, right: 10, bottom: 50, left: 50};
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        let annotations = svg1.append("g").attr("id","annotations");
        let chartArea = svg1.append("g").attr("id","points")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        const popExtent = d3.extent(data, d => d['track_pop'])
        const popScale = d3.scaleLinear()
                            .domain(popExtent)
                            .range([0, chartWidth])

        let bottomAxis = d3.axisBottom(popScale)

        annotations.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                   .call(bottomAxis)

        // danceability
        const danceExtent = d3.extent(data, d => d['danceability'])
        const danceScale = d3.scaleLinear()
                           .domain(danceExtent)
                           .range([chartHeight, 0])

        let danceAxis = d3.axisLeft(danceScale)

        annotations.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(danceAxis)

        let danceCircles = chartArea.selectAll("circles.dance").data(data)
                            .join("circle")
                            .attr("class", "dance")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => danceScale(d['danceability']))
                            .attr("fill", "#ff0050")
                            .attr("stroke", "black")
                            .attr("stroke-width", 0.5)
                            .attr("opacity", .6)

        chartArea.append("text")
                .attr("class", "title")
                .attr("x", (chartWidth / 2))
                .attr("y", 0 - (margin.top / 2))
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text("Danceability");

        var linearRegression = ss.linearRegression(data.map(d => [d.track_pop, d.danceability]))
        var linearRegressionLine = ss.linearRegressionLine(linearRegression)

        let regressionPoints = function(){
            const firstX = d3.min(data, d => d.track_pop);
            const lastX = d3.max(data, d => d.track_pop);

            const xCoordinates = [firstX, lastX];
            return xCoordinates.map(d => ({
                x: d,
                y: linearRegressionLine(d)
          }));
        }

        var lineGen = d3.line()
                 .x(d => popScale(d.x))
                 .y(d => danceScale(d.y))


        chartArea.append('path')
                 .datum(regressionPoints())
                 .attr('class', 'line')
                 .attr('stroke', '#397684')
                 .attr('stroke-width', 3)
                 .attr('d', lineGen);

        // energy
        const svg3 = d3.select("svg#energy")

        let annotations3 = svg3.append("g").attr("id","annotations3");
        let chartArea3 = svg3.append("g").attr("id","points3")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        annotations3.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                   .call(bottomAxis)


        const energyExtent = d3.extent(data, d => d['energy']);
        const energyScale = d3.scaleLinear()
                           .domain(energyExtent)
                           .range([chartHeight, 0]);
        let energyAxis = d3.axisLeft(energyScale);

        annotations3.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(energyAxis);

        let energyCircles = chartArea3.selectAll("circles.energy").data(data)
                            .join("circle")
                            .attr("class", "energy")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => energyScale(d['energy']))
                            .attr("fill", "#ff0050")
                            .attr("stroke", "black")
                            .attr("stroke-width", 0.5)
                            .attr("opacity", .6);

        chartArea3.append("text")
            .attr("class", "title")
            .attr("x", (chartWidth / 2))
            .attr("y", 0 - (margin.top / 2))
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .text("Energy");

        var linearRegression = ss.linearRegression(data.map(d => [d.track_pop, d.energy]))
        var linearRegressionLine = ss.linearRegressionLine(linearRegression)

        var lineGen = d3.line()
                 .x(d => popScale(d.x))
                 .y(d => energyScale(d.y))


        chartArea3.append('path')
                 .datum(regressionPoints())
                 .attr('class', 'line')
                 .attr('stroke', '#397684')
                 .attr('stroke-width', 3)
                 .attr('d', lineGen);


        // valence
        const svg4 = d3.select("svg#valence")

        let annotations4 = svg4.append("g").attr("id","annotations4");
        let chartArea4 = svg4.append("g").attr("id","points4")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        annotations4.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                   .call(bottomAxis)

        const valenceExtent = d3.extent(data, d => d['valence']);
        const valenceScale = d3.scaleLinear()
                           .domain(valenceExtent)
                           .range([chartHeight, 0]);
        let valenceAxis = d3.axisLeft(valenceScale);


        annotations4.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(valenceAxis);

        let valenceCircles = chartArea4.selectAll("circles.valence").data(data)
                            .join("circle")
                            .attr("class", "valence")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => valenceScale(d['valence']))
                            .attr("fill", "#ff0050")
                            .attr("stroke", "black")
                            .attr("stroke-width", 0.5)
                            .attr("opacity", .6);

        chartArea4.append("text")
            .attr("class", "title")
            .attr("x", (chartWidth / 2))
            .attr("y", 0 - (margin.top / 2))
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .text("Valence");

        var linearRegression = ss.linearRegression(data.map(d => [d.track_pop, d.valence]))
        var linearRegressionLine = ss.linearRegressionLine(linearRegression)

        var lineGen = d3.line()
                 .x(d => popScale(d.x))
                 .y(d => valenceScale(d.y))


        chartArea4.append('path')
                 .datum(regressionPoints())
                 .attr('class', 'line')
                 .attr('stroke', '#397684')
                 .attr('stroke-width', 3)
                 .attr('d', lineGen);

         // acousticness
        const svg6 = d3.select("svg#acousticness")

        let annotations6 = svg6.append("g").attr("id","annotations6");
        let chartArea6 = svg6.append("g").attr("id","points6")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        annotations6.append("g")
                .attr("class", "x axis")
                .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                .call(bottomAxis)


        const acousticnessExtent = d3.extent(data, d => d['acousticness']);
        const acousticnessScale = d3.scaleLinear()
                        .domain(acousticnessExtent)
                        .range([chartHeight, 0]);
        let acousticnessAxis = d3.axisLeft(acousticnessScale);


        annotations6.append("g")
                .attr("class", "y axis")
                .attr("transform",`translate(${margin.left-10},${margin.top})`)
                .call(acousticnessAxis);

        let acousticnessCircles = chartArea6.selectAll("circles.acousticness").data(data)
                            .join("circle")
                            .attr("class", "acousticness")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => acousticnessScale(d['acousticness']))
                            .attr("fill", "#ff0050")
                            .attr("stroke", "black")
                            .attr("stroke-width", 0.5)
                            .attr("opacity", .6);

        chartArea6.append("text")
                    .attr("class", "title")
                    .attr("x", (chartWidth / 2))
                    .attr("y", 0 - (margin.top / 2))
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .text("Acousticness");

        var linearRegression = ss.linearRegression(data.map(d => [d.track_pop, d.acousticness]))
        var linearRegressionLine = ss.linearRegressionLine(linearRegression)

        var lineGen = d3.line()
                 .x(d => popScale(d.x))
                 .y(d => acousticnessScale(d.y))


        chartArea6.append('path')
                 .datum(regressionPoints())
                 .attr('class', 'line')
                 .attr('stroke', '#397684')
                 .attr('stroke-width', 3)
                 .attr('d', lineGen);


        // track popularity against artist popularity
        const svg7 = d3.select("svg#artist_pop")

        let annotations7 = svg7.append("g").attr("id","annotations7");
        let chartArea7 = svg7.append("g").attr("id","points7")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        annotations7.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                   .call(bottomAxis)

        const artist_popExtent = d3.extent(data, d => d['artist_pop']);
        const artist_popScale = d3.scaleLinear()
                           .domain(artist_popExtent)
                           .range([chartHeight, 0]);
        let artist_popAxis = d3.axisLeft(artist_popScale);


        annotations7.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(artist_popAxis);

        let artist_popCircles = chartArea7.selectAll("circles.artist_pop").data(data)
                            .join("circle")
                            .attr("class", "artist_pop")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => artist_popScale(d['artist_pop']))
                            .attr("fill", "#ff0050")
                            .attr("stroke", "black")
                            .attr("stroke-width", 0.5)
                            .attr("opacity", .6);

      chartArea7.append("text")
        .attr("class", "artist-pop-text")
        .attr("x", (-margin.left+10))
        .attr("y", chartHeight/2)
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .text("Artist Popularity");

      chartArea7.append("text")
        .attr("x", (chartWidth / 2))
        .attr("y", (chartHeight + 45))
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .text("Track Popularity");


        // Combined chart
        let combo = d3.select("svg#combo")
        const widthC = combo.attr("width");
        const heightC = combo.attr("height");
        var margin = {top: 50, right: 150, bottom: 50, left: 100};
        const chartWidthC = widthC - margin.left - margin.right - 250;
        const chartHeightC = heightC - margin.top - margin.bottom - 50;
        let annotationsC = combo.append("g").attr("id","annotationsC");
        let chartAreaC = combo.append("g").attr("id","pointsC")
                        .attr("transform",`translate(${margin.left+30},${margin.top})`);

        const pop_bin = d3.bin()
                          .value(d => d.track_pop)
                          .thresholds([20, 40, 60, 80, 100]);

        const bins = pop_bin(data);

        data.bins = bins;
        data.bins.upperlimits = new Array();

        bins.forEach(array => {
            var sum_danceability = 0;
            var sum_valence = 0;
            var sum_acousticness = 0;
            var sum_energy = 0;

            array.forEach(element =>{
                sum_danceability += element.danceability;
                sum_valence += element.valence;
                sum_acousticness += element.acousticness;
                sum_energy += element.energy;
            })


            array.avg_danceability = sum_danceability/array.length;
            array.avg_valence = sum_valence/array.length;
            array.avg_acousticness = sum_acousticness/array.length;
            array.avg_energy = sum_energy/array.length;

            array.pop_range  = [array.x0, array.x1];

            data.bins.upperlimits.push(array.x1)


        });


        const popBinsExtent = d3.extent(data.bins.upperlimits);


        const labelScale = d3.scalePoint()
                             .domain(['danceability', 'valence', 'acousticness', 'energy'])
                             .range([chartHeightC-50, 50]);

        const xlabelScale = d3.scalePoint()
                             .domain(data.bins.upperlimits)
                             .range([50, chartWidthC-10])
                             .padding(0.1);

        const xlabelScaleTicks = d3.scalePoint()
                             .domain(['0 - 20', '21 - 40', '41 - 60', '61 - 80', '81 - 100'])
                             .range([50, chartWidthC-10])
                             .padding(0.1);



        let bottomAxisC = d3.axisBottom(xlabelScaleTicks)
                            .tickValues(['0 - 20', '21 - 40', '41 - 60', '61 - 80', '81 - 100'])
                            .ticks(5)
        
        let leftAxisC = d3.axisLeft(labelScale).ticks(4)


        annotationsC.append("g")
                   .attr("class", "x axis combo")
                   .attr("transform",`translate(${margin.left+30},${chartHeightC+margin.top})`)
                   .call(bottomAxisC)

        annotationsC.append("g")
                 .attr("class", "y axis combo")
                 .attr("transform",`translate(${margin.left+40},${margin.top})`)
                 .call(leftAxisC);

        // danceability
        const colorScale = d3.scaleThreshold(d3.schemePuRd[9])
                   .domain([0.1, .2, .3, .4, 0.5, .7, .8, .9, 1])

        const radiusScale= d3.scaleSqrt()
                            .domain([0,1])
                            .range([0, 20])

        let danceBubs = chartAreaC.append("g")
                            .selectAll("bubble")
                            .data(data.bins)
                            .join("circle")
                            .attr("cx", d => xlabelScale(d.x1))
                            .attr("cy", d => labelScale('danceability'))
                            .attr("r", d => radiusScale(d.avg_danceability))
                            .style("fill", d => colorScale(d.avg_danceability))
                            .style("opacity", "0.7")
                            .attr("stroke", "black")
                            .attr("stroke-width", .5);

        // valence

        let valBubs = chartAreaC.append("g")
                            .selectAll("bubble")
                            .data(data.bins)
                            .join("circle")
                            .attr("cx", d => xlabelScale(d.x1))
                            .attr("cy", d => labelScale('valence'))
                            .attr("r", d => radiusScale(d.avg_valence))
                            .style("fill", d => colorScale(d.avg_valence))
                            .style("opacity", "0.7")
                            .attr("stroke", "black")
                            .attr("stroke-width", .5);

        // acousticness

        let acousticnessBubs = chartAreaC.append("g")
                            .selectAll("bubble")
                            .data(data.bins)
                            .join("circle")
                            .attr("cx", d => xlabelScale(d.x1))
                            .attr("cy", d => labelScale('acousticness'))
                            .attr("r", d => radiusScale(d.avg_acousticness))
                            .style("fill", d => colorScale(d.avg_acousticness))
                            .style("opacity", "0.7")
                            .attr("stroke", "black")
                            .attr("stroke-width", .5);

        //energy


        var colorLegend = d3.legendColor()
                              .labelFormat(d3.format(".2f"))
                              .labels(d3.legendHelpers.thresholdLabels)
                              .scale(colorScale)
                              .shapePadding(5)
                              .shapeWidth(20)
                              .shapeHeight(20)
                              .labelOffset(12)
                              .title("Value Legend");

        combo.append("g")
                  .attr("transform", `translate(${chartWidthC+margin.right+50},${margin.top})`)
                  .call(colorLegend);

        let energyBubs = chartAreaC.append("g")
                            .selectAll("bubble")
                            .data(data.bins)
                            .join("circle")
                            .attr("cx", d => xlabelScale(d.x1))
                            .attr("cy", d => labelScale('energy'))
                            .attr("r", d => radiusScale(d.avg_energy))
                            .style("fill", d => colorScale(d.avg_energy))
                            .style("opacity", 0.7)
                            .attr("stroke", "black")
                            .attr("stroke-width", .5);

        chartAreaC.append("text")
                .attr("x", (chartWidthC / 2 + 15))
                .attr("y", (chartHeightC + margin.bottom))
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Track Popularity");

        combo.append("text")
                .attr("x", -chartHeightC/2)
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)" )
                .style("font-size", "18px")
                .text("Track Features");


    }
    requestData();

    </script>
    <!-- // var avg_danceability = sum_danceability/array.length;
    // var avg_valence = sum_valence/array.length;
    // var avg_acousticness = sum_acousticness/array.length;
    // var avg_energy = sum_energy/array.length;
    // const array1 = new Array(avg_danceability, avg_valence, avg_acousticness, avg_energy)

            // for (var i = 0; i < names.length; i += 1) {
            //     var data = {};
            //     for (var j = 0; j < array1.length; j += 1){
            //         data[names[j]] = array1[i];

            //     }
            //     array.push(data);

            //     // console.log(data)
            //     console.log(array)
            //}

            // console.log(array1);

            // console.log('array', bins.indexOf(array), 'avg dance: ', avg_danceability);
            // console.log('array', bins.indexOf(array), 'avg valence: ',avg_valence);
            // console.log('array', bins.indexOf(array), 'avg acoustic: ',avg_acousticness);
            // console.log('array', bins.indexOf(array), 'avg energy: ',avg_energy);

        //     // mode
        // const svg5 = d3.select("svg#mode")
        //
        // let annotations5 = svg5.append("g").attr("id","annotations5");
        // let chartArea5 = svg5.append("g").attr("id","points5")
        //                 .attr("transform",`translate(${margin.left},${margin.top})`);
        //
        // annotations5.append("g")
        //         .attr("class", "x axis")
        //         .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
        //         .call(bottomAxis)
        //
        // // points
        // const modeExtent = d3.extent(data, d => d['mode']);
        // const modeScale = d3.scaleLinear()
        //                 .domain(modeExtent)
        //                 .range([chartHeight, 0]);
        // let modeAxis = d3.axisLeft(modeScale);
        //
        //
        // annotations5.append("g")
        //         .attr("class", "y axis")
        //         .attr("transform",`translate(${margin.left-10},${margin.top})`)
        //         .call(modeAxis);
        //
        // let modeCircles = chartArea5.selectAll("circles.mode").data(data)
        //                     .join("circle")
        //                     .attr("class", "mode")
        //                     .attr("r", 4)
        //                     .attr("cx", d => popScale(d['track_pop']))
        //                     .attr("cy", d => modeScale(d['mode']))
        //                     .attr("fill", "#00f2ea")
        //                     .attr("opacity", .6);
        //
        // chartArea5.append("text")
        // .attr("x", (chartWidth / 2))
        // .attr("y", 0 - (margin.top / 2))
        // .attr("text-anchor", "middle")
        // .style("font-size", "16px")
        // .text("Mode");-->


</body>
</html>
