<html>
<head>
    <meta charset="UTF-8">

    <style>

    body {
      margin: 1in;
      font-family: 'Futura', sans-serif;
    }

    .axis {
        font-family: 'Futura', sans-serif;
    }

    .first {
        background-color: rgb(170, 236, 251, .05);
        border: 1px solid rgb(170, 236, 251, .3);
        padding: 40px;
    }

    .first .row {
        display: table;
        margin: 0 auto;
    }

    .title {
        font-weight: bold;
    }

    .axis.combo{
        font-size: 13;
    }

    .im-cover{
        background-color: rgb(118, 179, 193, 0.5);
        border: .5px solid rgb(118, 179, 193);
        padding: 30px;
    }

    div img, #artist_pop {
        margin: auto;
        display: block;
        margin-top: 30px;
    }

    .im-cover h2{
        font-weight: lighter;
        text-align: center;
        margin: 20px;
    }

    #icon {
        margin-bottom: 30px;
    }

    #combo {
        display: block;
        margin: auto;
    }

    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!--Source: susielu color legend https://d3-legend.susielu.com/ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.min.js"></script>
    <!-- Source: simple statistics (used for lin reg) https://simplestatistics.org/ -->
    <script src="https://unpkg.com/simple-statistics@7.7.6/dist/simple-statistics.min.js"></script>
</head>

<body>
    <h1>Project 1</h1>
    <h3>Sydney Bednar, Noorejehan Umar, Victoria Eshun</h3>
<div class="im-cover">
    <!-- Source: https://www.stickpng.com/img/icons-logos-emojis/tech-companies/tiktok-icon -->
    <img id="icon" src='tiktok-icon.png'/>
    <img src='title1.png'/>
    <h2>How do music features relate to track popularity? In this
    chart, we examine 4 features, danceability, valence, energy,
    and acousticness against track popularity see which of these
    features are most informative...</h2>
</div>
<div class="first">
    <div class="top row">
        <svg id="dance" width=500 height=500>
        </svg>

        <svg id="valence" width=500 height=500>
        </svg>
    </div>

    <div class="bottom row">
        <svg id="energy" width=500 height=500>
        </svg>
        <svg id="acousticness" width=500 height=500>
        </svg>
    </div>

</div>
<div class="im-cover">
    <img src='title2.png'/>
    <h2>In the charts above, the regression lines have slopes close to
    zero. Does this mean that all TikTok songs are the same regardless
    of popularity? Below, we look at the features all together to see
    what mixture of music features makes a true TikTok song...</h2>
</div>

<div class="first">
  <svg id="combo" width=1200 height=800>
    </svg>
</div>

</div>
<div class="im-cover">
    <img src='title3.png'/>
    <h2>We have the formula to creating a TikTok song, but we still want
        to know what makes some tracks more popular than others. Does the
        popularity of the artist matter? Let's see if artist popularity
        and track popularity are correlated.</h2>
</div>

<div class="first">
    <svg id="artist_pop" width=800 height=800>
    </svg>
</div>
    </p>

    <script>
    const requestData = async function() {
        const data = await d3.csv('TikTok_songs_2022.csv', d3.autoType);
        console.log(data);


        const svg1=d3.select("svg#dance")
        var width = svg1.attr("width");
        var height = svg1.attr("height");
        var margin = {top: 50, right: 10, bottom: 70, left: 50};
        var chartWidth = width - margin.left - margin.right;
        var chartHeight = height - margin.top - margin.bottom;

        let annotations = svg1.append("g").attr("id","annotations");
        let chartArea = svg1.append("g").attr("id","points")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        const popExtent = d3.extent(data, d => d['track_pop'])
        var popScale = d3.scaleLinear()
                            .domain(popExtent)
                            .range([0, chartWidth])

        var bottomAxis = d3.axisBottom(popScale)

        annotations.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                   .call(bottomAxis)

        // danceability
        const danceExtent = d3.extent(data, d => d['danceability'])
        const danceScale = d3.scaleLinear()
                           .domain(danceExtent)
                           .range([chartHeight, 0])

        let danceAxis = d3.axisLeft(danceScale)

        annotations.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(danceAxis)

        let danceCircles = chartArea.selectAll("circles.dance").data(data)
                            .join("circle")
                            .attr("class", "dance")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => danceScale(d['danceability']))
                            .attr("fill", "#ff0050")
                            .attr("stroke", "black")
                            .attr("stroke-width", 0.5)
                            .attr("opacity", .6)

        chartArea.append("text")
                .attr("class", "title")
                .attr("x", (chartWidth / 2))
                .attr("y", 0 - (margin.top / 2))
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text("Danceability");

        // lin reg code help: https://observablehq.com/@hydrosquall/simple-linear-regression-scatterplot-with-d3
        var linearRegression = ss.linearRegression(data.map(d => [d.track_pop, d.danceability]))
        var linearRegressionLine = ss.linearRegressionLine(linearRegression)

        let regressionPoints = function(){
            const firstX = d3.min(data, d => d.track_pop);
            const lastX = d3.max(data, d => d.track_pop);

            const xCoordinates = [firstX, lastX];
            return xCoordinates.map(d => ({
                x: d,
                y: linearRegressionLine(d)
          }));
        }

        var lineGen = d3.line()
                 .x(d => popScale(d.x))
                 .y(d => danceScale(d.y))


        chartArea.append('path')
                 .datum(regressionPoints())
                 .attr('class', 'line')
                 .attr('stroke', '#397684')
                 .attr('stroke-width', 3)
                 .attr('d', lineGen);

        // energy
        const svg3 = d3.select("svg#energy")

        let annotations3 = svg3.append("g").attr("id","annotations3");
        let chartArea3 = svg3.append("g").attr("id","points3")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        annotations3.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                   .call(bottomAxis)

        annotations3.append("text")
                  .attr("class", "x label")
                  .attr("transform",`translate(${margin.left+chartWidth/2},${chartHeight+margin.top+margin.bottom-20})`)
                  .attr("text-anchor", "middle")
                  .attr("dominant-baseline", "middle")
                  .text("Track Popularity")


        const energyExtent = d3.extent(data, d => d['energy']);
        const energyScale = d3.scaleLinear()
                           .domain(energyExtent)
                           .range([chartHeight, 0]);
        let energyAxis = d3.axisLeft(energyScale);

        annotations3.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(energyAxis);

        let energyCircles = chartArea3.selectAll("circles.energy").data(data)
                            .join("circle")
                            .attr("class", "energy")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => energyScale(d['energy']))
                            .attr("fill", "#ff0050")
                            .attr("stroke", "black")
                            .attr("stroke-width", 0.5)
                            .attr("opacity", .6);

        chartArea3.append("text")
            .attr("class", "title")
            .attr("x", (chartWidth / 2))
            .attr("y", 0 - (margin.top / 2))
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .text("Energy");

        var linearRegression = ss.linearRegression(data.map(d => [d.track_pop, d.energy]))
        var linearRegressionLine = ss.linearRegressionLine(linearRegression)

        var lineGen = d3.line()
                 .x(d => popScale(d.x))
                 .y(d => energyScale(d.y))


        chartArea3.append('path')
                 .datum(regressionPoints())
                 .attr('class', 'line')
                 .attr('stroke', '#397684')
                 .attr('stroke-width', 3)
                 .attr('d', lineGen);


        // valence
        const svg4 = d3.select("svg#valence")

        let annotations4 = svg4.append("g").attr("id","annotations4");
        let chartArea4 = svg4.append("g").attr("id","points4")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        annotations4.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                   .call(bottomAxis)

        const valenceExtent = d3.extent(data, d => d['valence']);
        const valenceScale = d3.scaleLinear()
                           .domain(valenceExtent)
                           .range([chartHeight, 0]);
        let valenceAxis = d3.axisLeft(valenceScale);


        annotations4.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(valenceAxis);

        let valenceCircles = chartArea4.selectAll("circles.valence").data(data)
                            .join("circle")
                            .attr("class", "valence")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => valenceScale(d['valence']))
                            .attr("fill", "#ff0050")
                            .attr("stroke", "black")
                            .attr("stroke-width", 0.5)
                            .attr("opacity", .6);

        chartArea4.append("text")
            .attr("class", "title")
            .attr("x", (chartWidth / 2))
            .attr("y", 0 - (margin.top / 2))
            .attr("text-anchor", "middle")
            .style("font-size", "16px")
            .text("Valence");

        var linearRegression = ss.linearRegression(data.map(d => [d.track_pop, d.valence]))
        var linearRegressionLine = ss.linearRegressionLine(linearRegression)

        var lineGen = d3.line()
                 .x(d => popScale(d.x))
                 .y(d => valenceScale(d.y))


        chartArea4.append('path')
                 .datum(regressionPoints())
                 .attr('class', 'line')
                 .attr('stroke', '#397684')
                 .attr('stroke-width', 3)
                 .attr('d', lineGen);

         // acousticness
        const svg6 = d3.select("svg#acousticness")

        let annotations6 = svg6.append("g").attr("id","annotations6");
        let chartArea6 = svg6.append("g").attr("id","points6")
                        .attr("transform",`translate(${margin.left},${margin.top})`);

        annotations6.append("g")
                .attr("class", "x axis")
                .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                .call(bottomAxis)


        const acousticnessExtent = d3.extent(data, d => d['acousticness']);
        const acousticnessScale = d3.scaleLinear()
                        .domain(acousticnessExtent)
                        .range([chartHeight, 0]);
        let acousticnessAxis = d3.axisLeft(acousticnessScale);


        annotations6.append("g")
                .attr("class", "y axis")
                .attr("transform",`translate(${margin.left-10},${margin.top})`)
                .call(acousticnessAxis);

        annotations6.append("text")
                  .attr("class", "x label")
                  .attr("transform",`translate(${margin.left+chartWidth/2},${chartHeight+margin.top+margin.bottom-20})`)
                  .attr("text-anchor", "middle")
                  .attr("dominant-baseline", "middle")
                  .text("Track Popularity")

        let acousticnessCircles = chartArea6.selectAll("circles.acousticness").data(data)
                            .join("circle")
                            .attr("class", "acousticness")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => acousticnessScale(d['acousticness']))
                            .attr("fill", "#ff0050")
                            .attr("stroke", "black")
                            .attr("stroke-width", 0.5)
                            .attr("opacity", .6);

        chartArea6.append("text")
                    .attr("class", "title")
                    .attr("x", (chartWidth / 2))
                    .attr("y", 0 - (margin.top / 2))
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .text("Acousticness");


        var linearRegression = ss.linearRegression(data.map(d => [d.track_pop, d.acousticness]))
        var linearRegressionLine = ss.linearRegressionLine(linearRegression)

        var lineGen = d3.line()
                 .x(d => popScale(d.x))
                 .y(d => acousticnessScale(d.y))


        chartArea6.append('path')
                 .datum(regressionPoints())
                 .attr('class', 'line')
                 .attr('stroke', '#397684')
                 .attr('stroke-width', 3)
                 .attr('d', lineGen);


        // track popularity against artist popularity
        const svg7 = d3.select("svg#artist_pop")
        var width = svg7.attr("width");
        var height = svg7.attr("height");
        var margin = {top: 50, right: 10, bottom: 70, left: 100};
        var chartWidth = width - margin.left - margin.right;
        var chartHeight = height - margin.top - margin.bottom;

        let annotations7 = svg7.append("g").attr("id","annotations7");
        let chartArea7 = svg7.append("g").attr("id","points7")
                        .attr("transform",`translate(${margin.left},${margin.top})`);


        var popScale = d3.scaleLinear()
                            .domain(popExtent)
                            .range([0, chartWidth])

        var bottomAxis = d3.axisBottom(popScale)

        annotations7.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                   .call(bottomAxis)

        const artist_popExtent = d3.extent(data, d => d['artist_pop']);
        const artist_popScale = d3.scaleLinear()
                           .domain(artist_popExtent)
                           .range([chartHeight, 0]);
        let artist_popAxis = d3.axisLeft(artist_popScale);


        annotations7.append("g")
                  .attr("class", "y axis")
                  .attr("transform",`translate(${margin.left-10},${margin.top})`)
                  .call(artist_popAxis);

        let artist_popCircles = chartArea7.selectAll("circles.artist_pop").data(data)
                            .join("circle")
                            .attr("class", "artist_pop")
                            .attr("r", 4)
                            .attr("cx", d => popScale(d['track_pop']))
                            .attr("cy", d => artist_popScale(d['artist_pop']))
                            .attr("fill", "#ff0050")
                            .attr("stroke", "black")
                            .attr("stroke-width", 0.5)
                            .attr("opacity", .6);

      annotations7.append("text")
        .attr("class", "artist-pop-text")
        .attr("x", -chartHeight/2)
        .attr("y", 50)
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .attr("transform", "rotate(-90)" )
        .text("Artist Popularity");

      chartArea7.append("text")
        .attr("x", (chartWidth / 2))
        .attr("y", (chartHeight + 50))
        .attr("text-anchor", "middle")
        .style("font-size", "16px")
        .text("Track Popularity");

        var linearRegression = ss.linearRegression(data.map(d => [d.track_pop, d.artist_pop]))
        var linearRegressionLine = ss.linearRegressionLine(linearRegression)

        var lineGen = d3.line()
                 .x(d => popScale(d.x))
                 .y(d => artist_popScale(d.y))


        chartArea7.append('path')
                 .datum(regressionPoints())
                 .attr('class', 'line')
                 .attr('stroke', '#397684')
                 .attr('stroke-width', 3)
                 .attr('d', lineGen);


        // Combined chart
        let combo = d3.select("svg#combo")
        const widthC = combo.attr("width");
        const heightC = combo.attr("height");
        var margin = {top: 50, right: 150, bottom: 50, left: 100};
        const chartWidthC = widthC - margin.left - margin.right - 250;
        const chartHeightC = heightC - margin.top - margin.bottom - 50;
        let annotationsC = combo.append("g").attr("id","annotationsC");
        let chartAreaC = combo.append("g").attr("id","pointsC")
                        .attr("transform",`translate(${margin.left+30},${margin.top})`);

        const pop_bin = d3.bin()
                          .value(d => d.track_pop)
                          .thresholds([20, 40, 60, 80, 100]);

        const bins = pop_bin(data);

        data.bins = bins;
        data.bins.upperlimits = new Array();

        bins.forEach(array => {
            var sum_danceability = 0;
            var sum_valence = 0;
            var sum_acousticness = 0;
            var sum_energy = 0;

            array.forEach(element =>{
                sum_danceability += element.danceability;
                sum_valence += element.valence;
                sum_acousticness += element.acousticness;
                sum_energy += element.energy;
            })


            array.avg_danceability = sum_danceability/array.length;
            array.avg_valence = sum_valence/array.length;
            array.avg_acousticness = sum_acousticness/array.length;
            array.avg_energy = sum_energy/array.length;

            array.pop_range  = [array.x0, array.x1];

            data.bins.upperlimits.push(array.x1)


        });


        const popBinsExtent = d3.extent(data.bins.upperlimits);


        const labelScale = d3.scalePoint()
                             .domain(['danceability', 'valence', 'acousticness', 'energy'])
                             .range([chartHeightC-50, 50]);

        const xlabelScale = d3.scalePoint()
                             .domain(data.bins.upperlimits)
                             .range([50, chartWidthC-10])
                             .padding(0.1);

        const xlabelScaleTicks = d3.scalePoint()
                             .domain(['0 - 20', '21 - 40', '41 - 60', '61 - 80', '81 - 100'])
                             .range([50, chartWidthC-10])
                             .padding(0.1);



        let bottomAxisC = d3.axisBottom(xlabelScaleTicks)
                            .tickValues(['0 - 20', '21 - 40', '41 - 60', '61 - 80', '81 - 100'])
                            .ticks(5)
        
        let leftAxisC = d3.axisLeft(labelScale).ticks(4)


        annotationsC.append("g")
                   .attr("class", "x axis combo")
                   .attr("transform",`translate(${margin.left+30},${chartHeightC+margin.top})`)
                   .call(bottomAxisC)

        annotationsC.append("g")
                 .attr("class", "y axis combo")
                 .attr("transform",`translate(${margin.left+40},${margin.top})`)
                 .call(leftAxisC);

        // danceability
        const colorScale = d3.scaleThreshold(d3.schemePuRd[9])
                   .domain([0.1, .2, .3, .4, 0.5, .7, .8, .9, 1])

        const radiusScale= d3.scaleSqrt()
                            .domain([0,1])
                            .range([0, 20])

        let danceBubs = chartAreaC.append("g")
                            .selectAll("bubble")
                            .data(data.bins)
                            .join("circle")
                            .attr("cx", d => xlabelScale(d.x1))
                            .attr("cy", d => labelScale('danceability'))
                            .attr("r", d => radiusScale(d.avg_danceability))
                            .style("fill", d => colorScale(d.avg_danceability))
                            .style("opacity", "0.7")
                            .attr("stroke", "black")
                            .attr("stroke-width", .5);

        // valence

        let valBubs = chartAreaC.append("g")
                            .selectAll("bubble")
                            .data(data.bins)
                            .join("circle")
                            .attr("cx", d => xlabelScale(d.x1))
                            .attr("cy", d => labelScale('valence'))
                            .attr("r", d => radiusScale(d.avg_valence))
                            .style("fill", d => colorScale(d.avg_valence))
                            .style("opacity", "0.7")
                            .attr("stroke", "black")
                            .attr("stroke-width", .5);

        // acousticness

        let acousticnessBubs = chartAreaC.append("g")
                            .selectAll("bubble")
                            .data(data.bins)
                            .join("circle")
                            .attr("cx", d => xlabelScale(d.x1))
                            .attr("cy", d => labelScale('acousticness'))
                            .attr("r", d => radiusScale(d.avg_acousticness))
                            .style("fill", d => colorScale(d.avg_acousticness))
                            .style("opacity", "0.7")
                            .attr("stroke", "black")
                            .attr("stroke-width", .5);

        //energy


        var colorLegend = d3.legendColor()
                              .labelFormat(d3.format(".2f"))
                              .labels(d3.legendHelpers.thresholdLabels)
                              .scale(colorScale)
                              .shapePadding(5)
                              .shapeWidth(20)
                              .shapeHeight(20)
                              .labelOffset(12)
                              .title("Value Legend");

        combo.append("g")
                  .attr("transform", `translate(${chartWidthC+margin.right+50},${margin.top})`)
                  .call(colorLegend);

        let energyBubs = chartAreaC.append("g")
                            .selectAll("bubble")
                            .data(data.bins)
                            .join("circle")
                            .attr("cx", d => xlabelScale(d.x1))
                            .attr("cy", d => labelScale('energy'))
                            .attr("r", d => radiusScale(d.avg_energy))
                            .style("fill", d => colorScale(d.avg_energy))
                            .style("opacity", 0.7)
                            .attr("stroke", "black")
                            .attr("stroke-width", .5);

        chartAreaC.append("text")
                .attr("x", (chartWidthC / 2 + 15))
                .attr("y", (chartHeightC + margin.bottom))
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Track Popularity");

        combo.append("text")
                .attr("x", -chartHeightC/2)
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)" )
                .style("font-size", "18px")
                .text("Track Features");


    }
    requestData();

    </script>
</body>
</html>
